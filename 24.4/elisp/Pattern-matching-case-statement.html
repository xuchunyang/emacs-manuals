<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 24.4.

Copyright Â© 1990-1996, 1998-2014 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Pattern matching case statement (GNU Emacs Lisp Reference Manual)</title>

<meta name="description" content="Pattern matching case statement (GNU Emacs Lisp Reference Manual)">
<meta name="keywords" content="Pattern matching case statement (GNU Emacs Lisp Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Conditionals.html#Conditionals" rel="up" title="Conditionals">
<link href="Combining-Conditions.html#Combining-Conditions" rel="next" title="Combining Conditions">
<link href="Conditionals.html#Conditionals" rel="prev" title="Conditionals">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="./manual.css">


</head>

<body lang="en">
<a name="Pattern-matching-case-statement"></a>
<div class="header">
<p>
Up: <a href="Conditionals.html#Conditionals" accesskey="u" rel="up">Conditionals</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Pattern-matching-case-statement-1"></a>
<h4 class="subsection">10.2.1 Pattern matching case statement</h4>
<a name="index-pcase"></a>
<a name="index-pattern-matching"></a>

<p>To compare a particular value against various possible cases, the macro
<code>pcase</code> can come handy.  It takes the following form:
</p>
<div class="example">
<pre class="example">(pcase <var>exp</var> <var>branch</var>1 <var>branch</var>2 <var>branch</var>3 &hellip;)
</pre></div>

<p>where each <var>branch</var> takes the form <code>(<var>upattern</var>
<var>body-forms</var>&hellip;)</code>.
</p>
<p>It will first evaluate <var>exp</var> and then compare the value against each
<var>upattern</var> to see which <var>branch</var> to use, after which it will run the
corresponding <var>body-forms</var>.  A common use case is to distinguish
between a few different constant values:
</p>
<div class="example">
<pre class="example">(pcase (get-return-code x)
  (`success       (message &quot;Done!&quot;))
  (`would-block   (message &quot;Sorry, can't do it now&quot;))
  (`read-only     (message &quot;The shmliblick is read-only&quot;))
  (`access-denied (message &quot;You do not have the needed rights&quot;))
  (code           (message &quot;Unknown return code %S&quot; code)))
</pre></div>

<p>In the last clause, <code>code</code> is a variable that gets bound to the value that
was returned by <code>(get-return-code x)</code>.
</p>
<p>To give a more complex example, a simple interpreter for a little
expression language could look like (note that this example requires
lexical binding):
</p>
<div class="example">
<pre class="example">(defun evaluate (exp env)
  (pcase exp
    (`(add ,x ,y)       (+ (evaluate x env) (evaluate y env)))
    (`(call ,fun ,arg)  (funcall (evaluate fun env) (evaluate arg env)))
    (`(fn ,arg ,body)   (lambda (val)
                          (evaluate body (cons (cons arg val) env))))
    ((pred numberp)     exp)
    ((pred symbolp)     (cdr (assq exp env)))
    (_                  (error &quot;Unknown expression %S&quot; exp))))
</pre></div>

<p>Where <code>`(add ,x ,y)</code> is a pattern that checks that <code>exp</code> is a three
element list starting with the symbol <code>add</code>, then extracts the second and
third elements and binds them to the variables <code>x</code> and <code>y</code>.
<code>(pred numberp)</code> is a pattern that simply checks that <code>exp</code>
is a number, and <code>_</code> is the catch-all pattern that matches anything.
</p>
<p>Here are some sample programs including their evaluation results:
</p>
<div class="example">
<pre class="example">(evaluate '(add 1 2) nil)                 ;=&gt; 3
(evaluate '(add x y) '((x . 1) (y . 2)))  ;=&gt; 3
(evaluate '(call (fn x (add 1 x)) 2) nil) ;=&gt; 3
(evaluate '(sub 1 2) nil)                 ;=&gt; error
</pre></div>

<p>There are two kinds of patterns involved in <code>pcase</code>, called
<em>U-patterns</em> and <em>Q-patterns</em>.  The <var>upattern</var> mentioned above
are U-patterns and can take the following forms:
</p>
<dl compact="compact">
<dt><code>`<var>qpattern</var></code></dt>
<dd><p>This is one of the most common form of patterns.  The intention is to mimic the
backquote macro: this pattern matches those values that could have been built
by such a backquote expression.  Since we&rsquo;re pattern matching rather than
building a value, the unquote does not indicate where to plug an expression,
but instead it lets one specify a U-pattern that should match the value at
that location.
</p>
<p>More specifically, a Q-pattern can take the following forms:
</p><dl compact="compact">
<dt><code>(<var>qpattern1</var> . <var>qpattern2</var>)</code></dt>
<dd><p>This pattern matches any cons cell whose <code>car</code> matches <var>QPATTERN1</var> and
whose <code>cdr</code> matches <var>PATTERN2</var>.
</p></dd>
<dt><code><var>atom</var></code></dt>
<dd><p>This pattern matches any atom <code>equal</code> to <var>atom</var>.
</p></dd>
<dt><code>,<var>upattern</var></code></dt>
<dd><p>This pattern matches any object that matches the <var>upattern</var>.
</p></dd>
</dl>

</dd>
<dt><code><var>symbol</var></code></dt>
<dd><p>A mere symbol in a U-pattern matches anything, and additionally let-binds this
symbol to the value that it matched, so that you can later refer to it, either
in the <var>body-forms</var> or also later in the pattern.
</p></dd>
<dt><code>_</code></dt>
<dd><p>This so-called <em>don&rsquo;t care</em> pattern matches anything, like the previous
one, but unlike symbol patterns it does not bind any variable.
</p></dd>
<dt><code>(pred <var>pred</var>)</code></dt>
<dd><p>This pattern matches if the function <var>pred</var> returns non-<code>nil</code> when
called with the object being matched.
</p></dd>
<dt><code>(or <var>upattern1</var> <var>upattern2</var>&hellip;)</code></dt>
<dd><p>This pattern matches as soon as one of the argument patterns succeeds.
All argument patterns should let-bind the same variables.
</p></dd>
<dt><code>(and <var>upattern1</var> <var>upattern2</var>&hellip;)</code></dt>
<dd><p>This pattern matches only if all the argument patterns succeed.
</p></dd>
<dt><code>(guard <var>exp</var>)</code></dt>
<dd><p>This pattern ignores the object being examined and simply succeeds if <var>exp</var>
evaluates to non-<code>nil</code> and fails otherwise.  It is typically used inside
an <code>and</code> pattern.  For example, <code>(and x (guard (&lt; x 10)))</code>
is a pattern which matches any number smaller than 10 and let-binds it to
the variable <code>x</code>.
</p></dd>
</dl>

<hr>
<div class="header">
<p>
Up: <a href="Conditionals.html#Conditionals" accesskey="u" rel="up">Conditionals</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
